## ООП Практикум, Домашно 1, Обратна връзка

### Теодора Петкова 62538

**Задача 1:**

* Добра практика е, когато имаш стойности, които са специфични за задачата, както например стойностите за ден, месец и година по подразбиране, или да ги отделиш в глобални константи, или като макроси в хедъра на класа, за който са. После си ги достъпвай навсякъде с името им:

  ```c++
  const unsigned short DEFAULT_DAY = 1;
  const unsigned short DEFAULT_MONTH = 1;
  const unsigned short DEFAULT_YEAR = 2000;
  
  //или
  
  #define DEFAULT_DAY 1
  #define DEFAULT_MONTH 1
  #define DEFAULT_YEAR 2000
  ```

  Това важи и за местата където се използват и месецит, така че може да си направиш същото и за всеки месец:

  ```c++
  #define FEBRUARY 2 // или 1
  //...
  #define DECEMER 12 // или 11
  ```

* Функции, които не променят състоянието на текущия обект, трябва да бъдат декларирани като константни, т.е. всички тези функции, който не променят стойности на член-данните на обекта трябва да бъдат декларирани по следния начин:

  ```c++
  bool isLeapYear() const;
  int daysToXmas() const;
  int daysToNewYear() const;
  int daysToDate(Date _date) const;
  bool isLaterThen(Date _date) const;
  int numOfTheDay() const;
  bool validateDate(unsigned short day,unsigned short month,unsigned int year);
  bool yearIsLeap(unsigned int year);
  ```
  
  Докато примерно във функциите:

  ```c++
void addDays(int);
  void removeDays(int);
  ```
  
  ти променяш стойностите на член-данните на текущия ти обект и коректно не са декларирани като константни.

* Можеше да използваш във функциите **daysToXmas()**, **daysToNewYear()** и **isLaterThan(Date)**  функцията, която си направил **daysTo(Date)**. Виждам, че си го направила благодарение на други функции, с които си спестила писане, така че го взимам предвид.

**Задача 2**:

* Ползвай за 26, 101, 20 (които представляват размерите) или глобални констатнти или макроси, както описах за първа задача;

* **class Deck**:
  * Щом ще ползваш динамична памет за тесттетата, трябваше да имплементираш Голяма четворка. Не е това акцента на домашното(освен за класа **Duelist** и динамичния низ *name*) и затова няма да го взема предвид, че е некоректно.
  
  * Методите:
  
    ```c++
    unsigned int getMagicCardCount();
    unsigned int getMonsterCardCount();
    ```
  
    трябва да бъдат декларирани като константни:
  
    ```c++
    unsigned int getMagicCardCount() const;
    unsigned int getMonsterCardCount() const;
    ```
  
    И те не променят съдъжанието на класа.
  
  * Констркуторът на Deck, който приема една магическа и една карта чудовище не е нужен и не е приложим;
  
  * Ако имаш сетъри за magicCardsCount и monsterCardsCount трябва да съобразиш, че в този случай не е добра да бъдат публични, понеже какво е състоянието на тези променливи не трябва да зависи от външни класове.
  
* **class Duelist**:

  * strcpy се грижи за '/0', така че след като заделяш динамична памет за низ, не е нужно да правиш:

    ```c++
    this->name = new char[strlen(_name) + 1];
    strcpy(this->name, _name);
    this->name[strlen(_name) + 1]='\0'; //от това няма нужда, strcpy се грижи за нея
    ```

  * Коректна ти е Голямата четворка, която си имплементирала в този клас и си закоментирала, но ще ти кажа защо не работи както трябва: защото в Deck ползваш динамична памет, а там не си имплементирала Голяма четворка и в частност operator= и copy конструктор, който позваш в Duelist. И затова се получава случай, в който два обекта сочат към една и съща памет и съответно се случва два пъти освобождаване в последствие на една и съща памет.

  